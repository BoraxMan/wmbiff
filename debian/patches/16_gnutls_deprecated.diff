Description: Do not used deprecated/removed old
 gnutls_certificate_verify_peers() function, but use slightly less old
 gnutls_certificate_verify_peers2() instead.
 Pulled from 4e9e018b2236e00aa591f1d5d99ec59f74475480.
Author: VLASIU <gabriel@vlasiu.net>
Bug-Debian: http://bugs.debian.org/ #624083
Origin: upstream, http://repo.or.cz/w/dockapps.git/commit/4e9e018b2236e00aa591f1d5d99ec59f74475480
Forwarded: not-needed
Last-Update: 2014-06-09

--- a/wmbiff/gnutls-common.c
+++ b/wmbiff/gnutls-common.c
@@ -334,15 +334,17 @@ void print_openpgp_info(gnutls_session s
 void print_cert_vrfy(gnutls_session session)
 {
 
-	int status;
-	status = gnutls_certificate_verify_peers(session);
+	unsigned int status;
+	int ret;
+	ret = gnutls_certificate_verify_peers2(session, &status);
 	printf("\n");
-
-	if (status == GNUTLS_E_NO_CERTIFICATE_FOUND) {
+	
+	if (ret == GNUTLS_E_NO_CERTIFICATE_FOUND) {
 		printf("- Peer did not send any certificate.\n");
 		return;
 	}
-	if (status < 0) {
+
+	if (ret < 0) {
 		printf("- Could not verify certificate (err: %s)\n",
 		       gnutls_strerror(status));
 		return;
--- a/wmbiff/tlsComm.c
+++ b/wmbiff/tlsComm.c
@@ -340,6 +340,16 @@ bad_certificate(const struct connection_
 	}
 }
 
+static void
+warn_certificate(const struct connection_state *scs, const char *msg)
+{
+	if (!SkipCertificateCheck) {
+		TDM(DEBUG_ERROR, "%s", msg);
+		TDM(DEBUG_ERROR, "to ignore this warning, run wmbiff "
+			"with the -skip-certificate-check option\n");
+	}
+}
+
 /* a start of a hack at verifying certificates.  does not
    provide any security at all.  I'm waiting for either
    gnutls to make this as easy as it should be, or someone
@@ -410,32 +420,45 @@ static void
 tls_check_certificate(struct connection_state *scs,
 					  const char *remote_hostname) 
 {
-	int certstat;
+	int ret;
+	unsigned int certstat;
 	const gnutls_datum *cert_list;
-	int cert_list_size = 0;
+	unsigned int cert_list_size = 0;
 	gnutls_x509_crt cert;
 
 	if (gnutls_auth_get_type(scs->tls_state) != GNUTLS_CRD_CERTIFICATE) {
 		bad_certificate(scs, "Unable to get certificate from peer.\n");
 		return;	/* bad_cert will exit if -skip-certificate-check was not given */
 	}
-	certstat = gnutls_certificate_verify_peers(scs->tls_state);
-	if (certstat == GNUTLS_E_NO_CERTIFICATE_FOUND) {
-		bad_certificate(scs, "server presented no certificate.\n");
+	ret = gnutls_certificate_verify_peers2(scs->tls_state, &certstat);
+
+	if (ret < 0) {
+		char errbuf[1024];
+
+		snprintf(errbuf, 1024, "could not verify certificate: %s (%d).\n",
+			gnutls_strerror(ret), ret);
+		bad_certificate(scs, (ret == GNUTLS_E_NO_CERTIFICATE_FOUND ?
+			"server presented no certificate.\n" :
+			errbuf));
+		return;
 #ifdef GNUTLS_CERT_CORRUPTED
 	} else if (certstat & GNUTLS_CERT_CORRUPTED) {
 		bad_certificate(scs, "server's certificate is corrupt.\n");
 #endif
 	} else if (certstat & GNUTLS_CERT_REVOKED) {
 		bad_certificate(scs, "server's certificate has been revoked.\n");
+	} else if (certstat & GNUTLS_CERT_EXPIRED) {
+		bad_certificate(scs, "server's certificate is expired.\n");
+	} else if (certstat & GNUTLS_CERT_INSECURE_ALGORITHM) {
+		warn_certificate(scs, "server's certificate use an insecure algorithm.\n");
 	} else if (certstat & GNUTLS_CERT_INVALID) {
 		if (gnutls_certificate_type_get(scs->tls_state) == GNUTLS_CRT_X509) {
 			/* bad_certificate(scs, "server's certificate is not trusted.\n"
 			   "there may be a problem with the certificate stored in your certfile\n"); */
 		} else {
 			bad_certificate(scs,
-							"server's certificate is invalid or not X.509.\n"
-							"there may be a problem with the certificate stored in your certfile\n");
+				"server's certificate is invalid or not X.509.\n"
+				"there may be a problem with the certificate stored in your certfile\n");
 		}
 #if defined(GNUTLS_CERT_SIGNER_NOT_FOUND)
 	} else if (certstat & GNUTLS_CERT_SIGNER_NOT_FOUND) {
